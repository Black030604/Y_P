                          Основные принципы ООП

Инкапсуляция

Инкапсуляция предполагает сокрытие деталей реализации, связывание данных и методов для их обработки в классе. Поля в классе делают скрытыми, для доступа к полю класса в классе описывают свойство. В нем указывается метод для установки значения поля и метод получения значения поля.
Описание свойства: 

тип_свойства   название_свойства
{
get 
{ //получение значения свойства };
set 
{ //установка значения свойства }
} 

Свойство создается для поля, тип свойства совпадает с типом поля.
В блоке “get” выполняется действие по получению значения свойства. В этом блоке с помощью оператора return возвращает некоторое значение.
В блоке “set” устанавливается значение свойства. В этом блоке с помощью параметра value можно получить значение, которое передано свойству.
Имя свойства может быть любым, но чаще свойства называют так же как и поле, но первая буква заглавная. Например:

class Person
{
private string name;
public string Name
{
get { return name; }
set { name=value; }
}
}

В программе можно обращаться к свойству, как к обычному полю:

имя_обьекта.Имя_свойства

Если свойству объекта присваивается какое-нибудь значение, то срабатывает блок set, а передаваемое значение передается в параметр value:

Person.Name = “Оля”;

Если нужно получить значение свойства, то срабатывает блок get, который возвращает значение поля name:

Console.WriteLine(Person.Name);

Если свойство имеет только блок set, тогда это свойство доступно только для записи. Если свойство имеет только блок get, то такое свойство доступно только для чтения.
В случае, если полей много, то оформлять для каждого поля свойства бывает утомительным, в C# добавлены автоматические свойства:

тип_свойства  название_свойства { get; set; }

Например:

class Person
{
public string Name { get; set; }
public int Age { get; set; }
public Person ( string name, int age )
{
Name=name;
Age=age;
}
}

Поля для свойства не прописаны в классе, а компилятор автоматически генерирует их при компиляции.
Если не указать для объекта класса Person значение свойств Name и Age, то будут действовать значения по умолчанию. Например:

class Person
{
public string Name { get; set; }
public int Age { get; set; }
}
static void Main ( string [] args )
{
Person person = new Person ();
person.Name = “Оля”;
person.Age = 20;
Console.WriteLine( person.Name + “ ” + person.Age.ToString());
}

Сокращенная запись свойства:

class Person 
{
string name;
public string Name 
{
get => name;
set => name = value;
}

Наследование

Наследование позволяет создавать новые классы на основе существующих классов, наследуя их атрибуты и методы. Это способствует повторному использованию кода и упрощает его структуру.
Класс, от которого происходит наследование, называется родительским или базовым, класс который наследует – наследником.
Описание класса наследника:

Имя_класса_наследника : имя_базового_класса
{ 
// тело класса наследника
}

Класс наследник автоматически получает все поля, методы и свойства базового класса. При этом открытые (public) и защищенные (protected) поля, свойства и методы доступны наследнику и его свойствам и методам. Закрытые поля, методы и свойства доступны классу наследнику, но не доступны его методам и свойствам.
Класс Phone содержащий поле производитель и модель, метод получения информации.

class Phone
{
public string manufacturer = “Apple”;
public string model = “IPhone XR”;
public void Print()
{
Console.WriteLIne(“Мир Apple!”);
}
}
Класс Smartphone имеет поле цвет.
Класс Smartphone наследует поля и методы класса Phone.
class Smartphone : Phone
{
public string color = “Red”;
}

В классе Program:

class Program
{
static void Main()
{
Smartphone apple = new Smartphone(); // создание объекта класса  Smartphone
apple.print();  //вызов метода
Console.WriteLine(“Смартфон: “ + apple.manufacturer + “ ” + apple.model + “\nЦвет корпуса: “ + apple.color);
Console.ReadKey();
}
}

Как видно из примера выше, класс Smartphone наследует от класса Phone поля и метод, что позволяет использовать их в программе, инициализировав только объект Smartphone().
Конструкторы базового класса с параметрами не передаются при наследовании.
Все классы по умолчанию могут наследоваться, но имеются следующие ограничения:
-не поддерживается множественное наследование, класс может наследовать только от одного класса.
-нельзя унаследовать класс от статического класса.
-тип доступа к производному классу должен быть таким же, как у базового класса или более строгим.
С помощью base можно обратиться к конструктору родительского класса, то есть в заголовке конструктора наследника через “:” записывается base и в круглых скобках список параметров конструктора родительского класса.

class Person
{
public string Name{get;set;}
public Person(string Name)
{Name=name;}
public void Print()
{
Console.WriteLine(Name);
}

class Employee:Person
{
public string Company {get;set;}
public Employee(string name,string company);base(name)
{Company=company;}
}

В Main:

Person person = new Person(“bob”);
person.Print();
Employee employee = new Employee(“tom”,”microsoft”);
employee.Print();

Конструкторы не передаются производному классу при наследовании.
Если в базовом классе не определен конструктор, по умолчанию без параметров, а только конструкторы с параметрами, то в производном классе обязательно нужно вызывать один из этих конструкторов через ключевое слово base

class Pupil:Person
{
public int Number {get;set;}
public Pupil(string name, int age, int number):base (name, age);
{Number = number;} 
}

В Main:

{
Person person = new Person(“Оля”,20);
Console.WrtieLine(person.Name+”,”+person.Age.ToString());
Pupil pupil = new Pupil(“Коля”,11,5);
Console.WrtieLine(pupil.Name+”,”+pupil.Age.ToString()+”,”+pupil.Number.ToString());
}



Полиморфизм

Полиморфизм позволяет объектам разных классов обладать одинаковым интерфейсом, что позволяет использовать их взаимозаменяемость. Это упрощает разработку и делает код более гибким.
У него есть возможность определения единого по имени метода, применяемого ко всем объектам иерархии наследования, возможность иметь несколько методов с одним и тем же именем для различных объектов одной иерархии. Какой из одноименных методов, родительский или наследника будет выполняться при обращении к методу заданному именем, определяется типом объекта (родительский или потомок) и использованного метода.
При наследовании  возникает необходимость изменить в классе наследника функционал метода, который был унаследован от родительского класса, в этом случае класс – наследник может переопределять свойства и методы базового класса.
Те методы и свойства, которые нужно сделать доступными для переопределения, в базовом классе помечается модификатором virtual. Такие свойства называются виртуальными. Чтобы переопределить метод в классе – наследника, этот метод определяется с модификатором override.
Переопределенный метод в классе – наследника должен иметь тот же набор параметров, что и виртуальный метод базового класса.

class Person
{
public string Name{get;set;}
public Person(string name)
{ Name=name;}
public virtual void Print()
{Console.WriteLine(Name);}
}

class Employ: Person
{
public string Company{get;set;}
public Employee(string name, string company):base(name)
{Company=company;}
public override void Print()
{Console.WriteLine($”{name} работает в {company});}
}

Объекты этих классов:

Person person = new Person(“Маша”);
person.Print();
Employee rabotnik = new Employee(“Саша”,”Microsoft”) ;
rabotnik.Print();

При переопределении виртуального метода следует учитывать ряд ограничений:
-Виртуальный и переопределяемый метод должен иметь один и тот же модификатор доступа.
-Нельзя переопределить или объявить статический метод.

Процесс выбора реализации метода производится во время выполнения программы. Таким образом, связь между объектом  и методом будет осуществляться в процессе программы (ее выполнения).

Person person = new Employee(“Max”,”Microsoft”);
person.Print();

person – это обьект класса Person, но при вызове person.Print() выполняется реализация метода Print класса Employee.

Интерфейсы

Интерфейсы определяют набор методов, которые должны быть реализованы классами, которые их реализуют. Использование интерфейсов позволяет создавать более гибкие и расширяемые системы.
Они используются если надо определить функционал для группы разрозненных объектов, которые могут быть никак не связанны между собой.
Если классы относятся к единой системе классификации, то выбирается абстрактный класс, иначе выбирается интерфейс.
Интерфейс – это класс специального вида. Он может определять некоторый функционал, набор методов и свойств без реализации, затем этот функционал реализуют классы и структуры, которые принимают данные интерфейсы.
Обычно имя интерфейса начинается на букву “I” от слова interface.
На основе интерфейса можно создать класс наследник при этом все методы интерфейса должны в этом классе быть реализованы
Интерфейсы могут содержать:

-методы
-свойства
-индексаторы
-события
-статические поля и константы

Интерфейсы не могут определять не статические переменные

interface Imovable
{
//константа
const int minSpeed=0;
//статическая переменная
Static int maxSpeed=60;
// свойство
string Name{get;set;}
}

Как и у классов интерфейсы по умолчанию имеют уровень доступа internal, то есть такой интерфейс доступен только в рамках текущего проекта.
С помощью модификатора public можно сделать интерфейс общедоступным.
Методы и свойства интерфейса по умолчанию имеют модификатор public.




Абстрактные классы

Абстрактные классы содержат абстрактные методы, которые должны быть реализованы в подклассах. Они предоставляют общий функционал для всех подклассов и могут содержать как реализованные методы, так и абстрактные методы.

При его определении используется ключевое слово abstract.

Нельзя использовать конструктор абстрактного класса для создания экземпляра (обьекта) класса.
Абстрактный класс, который представляет некое ТС

Abstract class Transport
{
public  void Move()
{Console.WriteLine(“транспортное средство движения”);}
}
Нельзя Transport tesla = new Transport();
Можно создавать объект наследников абстрактного класса:
От класса Transport наследуется 3 класса, которые представляют различные типы ТС. Общий для них является метод является Move()-движение ТС:

//класс корабль
class Ship:Transport
{}

//класс самолет
class AirCraft:Transport
{}

//класс машины
class  Car:Transport
{}

Объекты этих классов:

Transport car = new Car();
Transport ship = new Ship();
Transport aircraft = new AirCraft();
car.Move();
ship.Move();
aircraft.Move();

Абстрактные члены класса определяются с помощью ключевого слова abstract не имеют никакого функционала. Абстрактные члены классов не должны иметь модификатора private. При этом производные класса обязаны переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе.
При переопределение в производном классе такой метод или свойство объявляются с модификатором override.

abstract class Transport
{public abctract void Move();}

class Ship:Transport
{ 
//нужно реализовать все абстрактные методы и свойства базового класса
public override void Move()
{Console.WriteLine(“корабль плывет”);}
}
static void Main(…)
{
Transport ship = new Ship();
ship.Move();
}

